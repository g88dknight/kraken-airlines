<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Kraken Airlines - AR Paper Plane</title>
        <link rel="icon" href="assets/ico.ico" type="image/x-icon" />
        <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
        <link
            rel="stylesheet"
            href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,1,0"
        />
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            @import url("https://fonts.googleapis.com/css2?family=Geist:wght@400;500;600;700&display=swap");

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                font-family:
                    "Geist",
                    -apple-system,
                    BlinkMacSystemFont,
                    sans-serif;
            }

            body {
                overflow: hidden;
                background: #000;
            }

            #videoElement {
                position: absolute;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                object-fit: cover;
            }

            #canvas3D {
                position: absolute;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                pointer-events: none;
            }

            .brand {
                position: absolute;
                top: 32px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 140;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 8px;
                pointer-events: none;
            }

            .brand img {
                height: 48px;
                display: block;
                filter: drop-shadow(0 2px 12px rgba(0, 0, 0, 0.35));
            }

            .brand-subtitle {
                font-size: 13px;
                letter-spacing: 0.4px;
                color: rgba(255, 255, 255, 0.75);
            }

            .material-symbols-rounded {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
                font-variation-settings:
                    "FILL" 1,
                    "wght" 400,
                    "GRAD" 0,
                    "opsz" 24;
            }

            .glass-surface {
                background: rgba(15, 23, 42, 0.32);
                border: 1px solid rgba(255, 255, 255, 0.28);
                backdrop-filter: blur(22px);
                box-shadow: 0 18px 36px rgba(15, 23, 42, 0.22);
            }

            .status-indicator {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                width: 168px;
                padding: 8px 16px;
                border-radius: 999px;
                font-weight: 600;
                color: rgba(255, 255, 255, 0.85);
                transition: all 0.3s ease;
            }

            .status-indicator .status-label {
                font-size: 13px;
                letter-spacing: 0.2px;
            }

            .status-indicator.success {
                background: rgba(34, 197, 94, 0.22);
                border-color: rgba(74, 222, 128, 0.45);
                color: #34d399;
            }

            .status-indicator.info {
                background: rgba(59, 130, 246, 0.22);
                border-color: rgba(96, 165, 250, 0.45);
                color: #60a5fa;
            }

            .status-indicator.highlight {
                background: rgba(251, 191, 36, 0.22);
                border-color: rgba(251, 191, 36, 0.48);
                color: #fbbf24;
            }

            .status-indicator.neutral {
                color: rgba(255, 255, 255, 0.9);
            }

            body.boarding .status-indicator {
                opacity: 0;
                transform: translateY(-12px);
                pointer-events: none;
            }

            .boarding-screen {
                position: fixed;
                inset: 0;
                background: #000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 120;
                opacity: 0;
                pointer-events: none;
                gap: 140px;
                transition: opacity 0.4s ease;
            }

            body.boarding .boarding-screen {
                opacity: 1;
                pointer-events: auto;
            }

            .boarding-content {
                width: min(480px, 90vw);
                display: flex;
                flex-direction: column;
                gap: 28px;
                align-items: center;
                text-align: center;
            }

            .boarding-instructions {
                padding: 28px 24px;
                border-radius: 28px;
                display: flex;
                flex-direction: column;
                gap: 22px;
                color: rgba(255, 255, 255, 0.92);
            }

            .boarding-title {
                font-size: 20px;
                font-weight: 600;
                text-align: center;
                letter-spacing: 0.4px;
            }

            .instruction-item {
                display: flex;
                gap: 16px;
                align-items: center;
            }

            .instruction-item + .instruction-item {
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                padding-top: 18px;
                margin-top: 4px;
            }

            .instruction-icon {
                width: 52px;
                height: 52px;
                border-radius: 18px;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .instruction-icon svg {
                width: 32px;
                height: 32px;
                stroke: rgba(255, 255, 255, 0.85);
                stroke-width: 2;
                fill: none;
                stroke-linecap: round;
                stroke-linejoin: round;
            }

            .instruction-icon svg circle {
                stroke-width: 1.8;
            }

            .instruction-text {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .instruction-text strong {
                font-size: 15px;
                font-weight: 600;
            }

            .instruction-text span {
                font-size: 13px;
                color: rgba(255, 255, 255, 0.7);
                line-height: 1.4;
            }

            .primary-btn {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                padding: 16px 36px;
                border-radius: 999px;
                color: white;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .primary-btn:hover {
                background: rgba(255, 255, 255, 0.18);
                transform: translateY(-2px);
                box-shadow: 0 16px 32px rgba(0, 0, 0, 0.35);
            }

            .bottom-ui {
                position: fixed;
                bottom: 24px;
                left: 0;
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 18px;
                z-index: 130;
            }

            .bottom-actions {
                display: flex;
                gap: 12px;
                pointer-events: auto;
                width: min(520px, 92vw);
                justify-content: center;
                flex-wrap: wrap;
            }

            body.boarding .bottom-actions {
                display: none;
            }

            .glass-btn {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                padding: 12px 20px;
                border-radius: 999px;
                color: white;
                font-weight: 600;
                font-size: 14px;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .glass-btn:hover {
                background: rgba(255, 255, 255, 0.24);
                transform: translateY(-1px);
            }

            .glass-btn:disabled,
            .glass-btn.busy {
                opacity: 0.55;
                cursor: wait;
            }

            .glass-btn.record {
                background: rgba(248, 113, 113, 0.18);
                border-color: rgba(248, 113, 113, 0.45);
                color: #fca5a5;
            }

            .glass-btn.record .material-symbols-rounded {
                color: currentColor;
            }

            .glass-btn.record.recording {
                background: rgba(239, 68, 68, 0.28);
                border-color: rgba(239, 68, 68, 0.6);
                color: #f87171;
            }

            .loading {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-size: 18px;
                font-weight: 500;
                text-align: center;
                z-index: 50;
            }

            .loading-spinner {
                width: 40px;
                height: 40px;
                border: 3px solid rgba(255, 255, 255, 0.3);
                border-top-color: white;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin: 0 auto 16px;
            }

            @keyframes spin {
                to {
                    transform: rotate(360deg);
                }
            }

            #canvasElement {
                display: none;
            }
        </style>
    </head>
    <body>
        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            Initializing camera...
        </div>

        <video id="videoElement" autoplay playsinline></video>
        <canvas id="canvas3D"></canvas>
        <canvas id="canvasElement"></canvas>

        <div class="brand">
            <img src="assets/logo-air.svg" alt="Kraken Airlines logo" />
            <p class="brand-subtitle">made æspecially for you</p>
            <div class="status-indicator neutral glass-surface" id="statusIndicator">
                <span class="material-symbols-rounded">flight_takeoff</span>
                <span class="status-label">Boarding</span>
            </div>
        </div>

        <div class="boarding-screen" id="boardingScreen">
            <div class="boarding-content">
                <div class="boarding-instructions glass-surface">
                    <h2 class="boarding-title">Gesture Controls</h2>
                    <div class="instruction-item">
                        <div class="instruction-icon">
                            <svg viewBox="0 0 32 32" aria-hidden="true">
                                <path d="M12 6v11" />
                                <path d="M12 17l8-6" />
                                <circle cx="20" cy="11.8" r="1.6" />
                                <path d="M20 12c2.2 0 4 1.8 4 4v6" />
                            </svg>
                        </div>
                        <div class="instruction-text">
                            <strong>Pinch to drag &amp; launch</strong>
                            <span>Двумя пальцами для перемещения и отпустите для запуска</span>
                        </div>
                    </div>
                    <div class="instruction-item">
                        <div class="instruction-icon">
                            <svg viewBox="0 0 32 32" aria-hidden="true">
                                <path d="M16 6v12" />
                                <path d="M12 12v10" />
                                <path d="M20 15v8" />
                                <path d="M12 22c0 2.6 1.9 4.7 4.5 4.7h1c2.6 0 4.5-2.1 4.5-4.7V20" />
                            </svg>
                        </div>
                        <div class="instruction-text">
                            <strong>Tilt wrist to steer</strong>
                            <span>Наклоняйте кисть вниз для управления наклоном самолёта</span>
                        </div>
                    </div>
                    <div class="instruction-item">
                        <div class="instruction-icon">
                            <svg viewBox="0 0 32 32" aria-hidden="true">
                                <path d="M9.5 9v11" />
                                <path d="M13 6.5v13.5" />
                                <path d="M17 6v14" />
                                <path d="M21 7.5v12.5" />
                                <path d="M24.5 12v8c0 3.3-2.7 6-6 6H16c-3.3 0-6-2.7-6-6v-4" />
                            </svg>
                        </div>
                        <div class="instruction-text">
                            <strong>Turn palm &amp; clench to land</strong>
                            <span>Поверните ладонь к себе и стисните кулак для посадки</span>
                        </div>
                    </div>
                </div>
                <button class="primary-btn glass-surface" id="takeoffBtn">
                    <span class="material-symbols-rounded">flight_takeoff</span>
                    <span class="label">Flight Takeoff</span>
                </button>
            </div>
        </div>

        <div class="bottom-ui">
            <div class="bottom-actions">
                <button class="glass-btn glass-surface" id="backToBoardingBtn">
                    <span class="material-symbols-rounded">undo</span>
                    <span class="label">To Boarding</span>
                </button>
                <button class="glass-btn glass-surface record" id="recordBtn">
                    <span class="material-symbols-rounded">fiber_manual_record</span>
                    <span class="label">Record</span>
                </button>
                <button class="glass-btn glass-surface" id="cameraToggleBtn">
                    <span class="material-symbols-rounded">cameraswitch</span>
                    <span class="label">Rear Camera</span>
                </button>
            </div>
        </div>

        <script type="module">
            // Three.js Setup
            const canvas3D = document.getElementById("canvas3D");
            const scene = new THREE.Scene();

            const renderer = new THREE.WebGLRenderer({
                canvas: canvas3D,
                alpha: true,
                antialias: true,
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000,
            );
            camera.position.z = 5;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-5, -3, -5);
            scene.add(backLight);

            // Load Paper Plane Model
            const planeGroup = new THREE.Group();
            scene.add(planeGroup);

            let planeModel;

            // Create paper plane geometry
            function createPaperPlane() {
                const geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    0, 0, 1.5, -1.2, 0, -0.6, 1.2, 0, -0.6, 0, 0.3, 0.2, 0, -0.3, -0.3, -0.4, 0,
                    -0.8, 0.4, 0, -0.8,
                ]);

                const indices = [
                    0, 1, 3, 0, 3, 2, 0, 2, 4, 0, 4, 1, 3, 1, 5, 3, 2, 6, 4, 5, 1, 4, 2, 6,
                ];

                geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                const material = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    shininess: 30,
                    side: THREE.DoubleSide,
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.set(0.6, 0.6, 0.6);
                planeGroup.add(mesh);
                planeModel = mesh;
            }

            createPaperPlane();
            planeGroup.position.set(0, -0.4, -4.5);
            planeGroup.rotation.set(0, 0, 0);

            // Plane States
            const PlaneState = {
                IDLE: "idle",
                DRAGGING: "dragging",
                ORBITING: "orbiting", // Autonomous flight loop
                CONTROLLED: "controlled", // Pointing gesture control
                TRICK: "trick",
            };

            let currentState = PlaneState.IDLE;
            let targetDistance = 4.6; // Distance from center
            let orbitAngle = 0;
            let orbitSpeed = 0.01;
            let smoothedHandX = 0;
            let smoothedHandY = 0;
            let wasPinching = false;
            const palmTilt = { roll: 0, pitch: 0 };
            let palmFacingCamera = false;
            let palmFacingDown = false;

            document.body.classList.remove("in-flight");
            document.body.classList.add("boarding");

            const statusIndicator = document.getElementById("statusIndicator");
            const takeoffBtn = document.getElementById("takeoffBtn");
            const backToBoardingBtn = document.getElementById("backToBoardingBtn");
            const recordBtn = document.getElementById("recordBtn");
            const cameraToggleBtn = document.getElementById("cameraToggleBtn");

            const statusConfig = {
                [PlaneState.IDLE]: {
                    label: "Boarding",
                    icon: "flight_takeoff",
                    variant: "neutral",
                },
                [PlaneState.ORBITING]: {
                    label: "On Flight",
                    icon: "flight",
                    variant: "success",
                },
                [PlaneState.DRAGGING]: {
                    label: "Drag",
                    icon: "pan_tool_alt",
                    variant: "neutral",
                },
                [PlaneState.CONTROLLED]: {
                    label: "Manual",
                    icon: "sports_esports",
                    variant: "info",
                },
                [PlaneState.TRICK]: {
                    label: "Trick",
                    icon: "auto_awesome",
                    variant: "highlight",
                },
            };

            function materialIcon(name) {
                return `<span class="material-symbols-rounded">${name}</span>`;
            }

            function updateStatusIndicator() {
                if (!statusIndicator) {
                    return;
                }
                const config = statusConfig[currentState] || statusConfig[PlaneState.IDLE];
                statusIndicator.className = `status-indicator glass-surface ${config.variant}`;
                statusIndicator.innerHTML = `${materialIcon(config.icon)}<span class="status-label">${config.label}</span>`;
            }

            function updateGestureDisplay(gesture) {}

            function setPlaneState(nextState) {
                if (currentState === nextState) {
                    return;
                }
                currentState = nextState;
                updateStatusIndicator();
            }

            updateStatusIndicator();

            // Trail System
            const trailPoints = [];
            const maxTrailLength = 80;
            let trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6,
                linewidth: 2,
            });
            const trailLine = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trailLine);

            function updateTrail() {
                if (
                    currentState === PlaneState.ORBITING ||
                    currentState === PlaneState.CONTROLLED ||
                    currentState === PlaneState.TRICK
                ) {
                    trailPoints.push(planeGroup.position.clone());
                }

                if (trailPoints.length > maxTrailLength) {
                    trailPoints.shift();
                }

                const positions = new Float32Array(trailPoints.length * 3);
                trailPoints.forEach((point, i) => {
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                });

                trailGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
                trailGeometry.attributes.position.needsUpdate = true;
            }

            // Hand Tracking State
            let handX = 0;
            let handY = 0;
            let handDetected = false;
            let gestureType = "none";
            let lastGesture = "none";

            // MediaPipe Hands
            const videoElement = document.getElementById("videoElement");
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                },
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7,
            });

            hands.onResults(onResults);

            const tempVecA = new THREE.Vector3();
            const tempVecB = new THREE.Vector3();
            const palmNormal = new THREE.Vector3();

            function calculatePalmNormal(landmarks) {
                const wrist = landmarks[0];
                const indexMcp = landmarks[5];
                const pinkyMcp = landmarks[17];

                tempVecA.set(indexMcp.x - wrist.x, indexMcp.y - wrist.y, indexMcp.z - wrist.z);
                tempVecB.set(pinkyMcp.x - wrist.x, pinkyMcp.y - wrist.y, pinkyMcp.z - wrist.z);
                palmNormal.copy(tempVecA.cross(tempVecB)).normalize();
                return palmNormal;
            }

            function updatePalmTilt(landmarks) {
                const wrist = landmarks[0];
                const middleMcp = landmarks[9];

                const direction = tempVecA
                    .set(middleMcp.x - wrist.x, middleMcp.y - wrist.y, middleMcp.z - wrist.z)
                    .normalize();

                // Convert to intuitive roll/pitch (clamped for stability)
                palmTilt.roll = THREE.MathUtils.clamp(-direction.x * 1.6, -0.8, 0.8);
                palmTilt.pitch = THREE.MathUtils.clamp((direction.y - 0.5) * 1.4, -0.5, 0.5);
            }

            function detectGesture(landmarks) {
                const wrist = landmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const indexPip = landmarks[6];
                const indexMcp = landmarks[5];
                const middleTip = landmarks[12];
                const middlePip = landmarks[10];
                const ringTip = landmarks[16];
                const ringPip = landmarks[14];
                const pinkyTip = landmarks[20];
                const pinkyPip = landmarks[18];

                // Calculate thumb-index distance for pinch
                const thumbIndexDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                        Math.pow(thumbTip.y - indexTip.y, 2) +
                        Math.pow(thumbTip.z - indexTip.z, 2),
                );

                // Check if fingers are extended
                const indexExtended = indexTip.y < indexMcp.y - 0.04;
                const middleExtended = middleTip.y < middlePip.y - 0.03;
                const ringExtended = ringTip.y < ringPip.y - 0.03;
                const pinkyExtended = pinkyTip.y < pinkyPip.y - 0.03;

                // Fist - all fingers closed
                if (!indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                    return "fist";
                }

                // Pinch - thumb and index close
                if (thumbIndexDist < 0.08) {
                    return "pinch";
                }

                // Peace sign - index and middle up, others down
                if (indexExtended && middleExtended && !ringExtended && !pinkyExtended) {
                    return "peace";
                }

                // Open palm - all fingers extended
                if (indexExtended && middleExtended && ringExtended && pinkyExtended) {
                    return "open_palm";
                }

                // Pointing - only index extended
                if (indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                    return "pointing";
                }

                return "none";
            }

            function onResults(results) {
                if (document.body.classList.contains("boarding")) {
                    handDetected = false;
                    gestureType = "none";
                    updateGestureDisplay("none");
                    setPlaneState(PlaneState.IDLE);
                    return;
                }

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];

                    const indexTip = landmarks[8];
                    const palmBase = landmarks[0];

                    handX = (indexTip.x - 0.5) * 2;
                    handY = (indexTip.y - 0.5) * -2;
                    // Smooth hand position
                    smoothedHandX += (handX - smoothedHandX) * 0.3;
                    smoothedHandY += (handY - smoothedHandY) * 0.3;

                    handDetected = true;
                    gestureType = detectGesture(landmarks);

                    updateGestureDisplay(gestureType);

                    const normal = calculatePalmNormal(landmarks);
                    palmFacingCamera = normal.z < -0.25;
                    palmFacingDown = normal.y > 0.1;
                    updatePalmTilt(landmarks);
                    if (!palmFacingDown) {
                        palmTilt.roll *= 0.3;
                        palmTilt.pitch *= 0.3;
                    }

                    if (gestureType === "pinch") {
                        wasPinching = true;
                        setPlaneState(PlaneState.DRAGGING);
                    } else if (wasPinching) {
                        launchPlane();
                    }

                    if (gestureType === "pointing" && currentState !== PlaneState.DRAGGING) {
                        setPlaneState(PlaneState.CONTROLLED);
                    } else if (
                        gestureType !== "pointing" &&
                        currentState === PlaneState.CONTROLLED
                    ) {
                        setPlaneState(PlaneState.ORBITING);
                    }

                    if (gestureType === "peace" && currentState === PlaneState.ORBITING) {
                        if (lastGesture !== "peace") {
                            doTrick();
                        }
                    }

                    if (
                        gestureType === "fist" &&
                        palmFacingCamera &&
                        currentState !== PlaneState.IDLE
                    ) {
                        landPlane();
                    }

                    lastGesture = gestureType;
                } else {
                    handDetected = false;
                    gestureType = "none";
                    updateGestureDisplay("none");
                    if (document.body.classList.contains("boarding")) {
                        setPlaneState(PlaneState.IDLE);
                    } else if (
                        currentState === PlaneState.DRAGGING ||
                        currentState === PlaneState.CONTROLLED
                    ) {
                        setPlaneState(PlaneState.ORBITING);
                    }
                    if (wasPinching) {
                        launchPlane();
                    }
                    wasPinching = false;
                }
            }

            function doTrick() {
                setPlaneState(PlaneState.TRICK);
                setTimeout(() => {
                    if (currentState === PlaneState.TRICK) {
                        setPlaneState(PlaneState.ORBITING);
                    }
                }, 1500);
            }

            function launchPlane() {
                wasPinching = false;
                const pos = planeGroup.position;
                const centerZ = pos.z + 6.5;
                const radius = THREE.MathUtils.clamp(
                    Math.sqrt(pos.x * pos.x + centerZ * centerZ),
                    3.6,
                    5.6,
                );
                targetDistance = radius;
                orbitAngle = Math.atan2(centerZ, pos.x || 0.0001);
                setPlaneState(PlaneState.ORBITING);
            }

            function landPlane() {
                wasPinching = false;
                setPlaneState(PlaneState.IDLE);
                targetDistance = 4.2;
                planeGroup.position.set(0, -0.4, -4.5);
                planeGroup.rotation.set(0, 0, 0);
            }

            // Camera Setup
            let cameraInstance;
            let currentFacingMode = "environment";
            let cameraStarting = false;

            function renderCameraError() {
                const loadingEl = document.getElementById("loading");
                loadingEl.innerHTML = `
                <div style="color: #ef4444; text-align: center;">
                    <div style='margin-bottom: 16px; display: flex; justify-content: center;'>
                        <span class="material-symbols-rounded" style="font-size: 48px; font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 48;">videocam_off</span>
                    </div>
                    <div style='font-size: 18px; margin-bottom: 8px;'>Camera Access Required</div>
                    <div style='font-size: 14px; opacity: 0.8;'>Please allow camera access to use this app</div>
                    <button onclick='location.reload()' style='margin-top: 20px; padding: 12px 24px; background: white; color: black; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;'>Retry</button>
                </div>
            `;
            }

            function updateCameraToggleLabel() {
                if (!cameraToggleBtn) {
                    return;
                }
                const label = cameraToggleBtn.querySelector(".label");
                if (label) {
                    label.textContent = "Switch Camera";
                }
            }

            async function startCamera(facingMode = currentFacingMode) {
                if (cameraStarting) {
                    return;
                }
                cameraStarting = true;
                currentFacingMode = facingMode;
                updateCameraToggleLabel();

                try {
                    if (cameraInstance) {
                        await cameraInstance.stop();
                    }
                } catch (stopError) {
                    console.warn("Camera stop error", stopError);
                }

                cameraInstance = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 1280,
                    height: 720,
                    facingMode: currentFacingMode,
                });

                try {
                    await cameraInstance.start();
                    document.getElementById("loading").style.display = "none";
                } catch (err) {
                    console.error("Camera error:", err);
                    renderCameraError();
                } finally {
                    cameraStarting = false;
                }
            }

            startCamera().catch((err) => {
                console.error("Camera start failure:", err);
                renderCameraError();
            });

            updateCameraToggleLabel();

            // UI Controls
            takeoffBtn.addEventListener("click", () => {
                document.body.classList.remove("boarding");
                document.body.classList.add("in-flight");
                planeGroup.position.set(0, -0.4, -4.5);
                planeGroup.rotation.set(0, 0, 0);
                targetDistance = 4.6;
                orbitAngle = 0;
                setPlaneState(PlaneState.ORBITING);
                updateGestureDisplay("none");
            });

            backToBoardingBtn.addEventListener("click", () => {
                document.body.classList.remove("in-flight");
                document.body.classList.add("boarding");
                setPlaneState(PlaneState.IDLE);
                updateGestureDisplay("none");
                handDetected = false;
                gestureType = "none";
                trailPoints.length = 0;
                targetDistance = 4.6;
                orbitAngle = 0;
                planeGroup.position.set(0, -0.4, -4.5);
                planeGroup.rotation.set(0, 0, 0);
            });

            cameraToggleBtn?.addEventListener("click", async () => {
                if (cameraStarting) {
                    return;
                }
                cameraToggleBtn.disabled = true;
                cameraToggleBtn.classList.add("busy");
                const nextFacingMode = currentFacingMode === "user" ? "environment" : "user";
                handDetected = false;
                gestureType = "none";
                updateGestureDisplay("none");
                await startCamera(nextFacingMode);
                cameraToggleBtn.disabled = false;
                cameraToggleBtn.classList.remove("busy");
            });

            // Screen Recording with MP4 support (fallback to WebM when necessary)
            let mediaRecorder;
            let recordedChunks = [];
            let isRecording = false;
            let activeRecordingExtension = "mp4";

            function drawVideoCover(ctx, video, width, height) {
                const vWidth = video.videoWidth || width;
                const vHeight = video.videoHeight || height;
                if (!vWidth || !vHeight) {
                    ctx.drawImage(video, 0, 0, width, height);
                    return;
                }
                const videoAspect = vWidth / vHeight;
                const canvasAspect = width / height;
                let sx = 0;
                let sy = 0;
                let sWidth = vWidth;
                let sHeight = vHeight;
                if (videoAspect > canvasAspect) {
                    sHeight = vHeight;
                    sWidth = sHeight * canvasAspect;
                    sx = (vWidth - sWidth) / 2;
                } else {
                    sWidth = vWidth;
                    sHeight = sWidth / canvasAspect;
                    sy = (vHeight - sHeight) / 2;
                }
                ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, width, height);
            }

            recordBtn.addEventListener("click", async () => {
                if (!isRecording) {
                    try {
                        const recordCanvas = document.createElement("canvas");
                        const canvasWidth =
                            canvas3D.width || canvas3D.clientWidth || window.innerWidth;
                        const canvasHeight =
                            canvas3D.height || canvas3D.clientHeight || window.innerHeight;
                        recordCanvas.width = canvasWidth;
                        recordCanvas.height = canvasHeight;
                        const ctx = recordCanvas.getContext("2d");

                        const canvasStream = recordCanvas.captureStream(30);

                        function drawFrame() {
                            if (!isRecording) {
                                return;
                            }
                            drawVideoCover(
                                ctx,
                                videoElement,
                                recordCanvas.width,
                                recordCanvas.height,
                            );
                            ctx.drawImage(canvas3D, 0, 0, recordCanvas.width, recordCanvas.height);
                            requestAnimationFrame(drawFrame);
                        }

                        const mimeCandidates = [
                            { type: "video/mp4;codecs=avc1.42E01E,mp4a.40.2", extension: "mp4" },
                            { type: "video/mp4;codecs=avc1.42E01E", extension: "mp4" },
                            { type: "video/mp4", extension: "mp4" },
                            { type: "video/webm;codecs=h264", extension: "webm" },
                            { type: "video/webm;codecs=vp9", extension: "webm" },
                            { type: "video/webm;codecs=vp8", extension: "webm" },
                        ];

                        const selectedMime = mimeCandidates.find((candidate) =>
                            MediaRecorder.isTypeSupported(candidate.type),
                        );

                        if (!selectedMime) {
                            throw new Error("No supported recording mime type");
                        }

                        activeRecordingExtension = selectedMime.extension;

                        if (selectedMime.extension !== "mp4") {
                            console.warn(
                                "MP4 recording is not supported by this browser. Falling back to",
                                selectedMime.type,
                            );
                        }

                        mediaRecorder = new MediaRecorder(canvasStream, {
                            mimeType: selectedMime.type,
                            videoBitsPerSecond: 6_000_000,
                        });

                        recordedChunks = [];
                        mediaRecorder.ondataavailable = (e) => {
                            if (e.data.size > 0) recordedChunks.push(e.data);
                        };
                        mediaRecorder.onstop = () => {
                            const blob = new Blob(recordedChunks, { type: selectedMime.type });
                            const fileName = `kraken-airlines-${Date.now()}.${activeRecordingExtension}`;
                            const file = new File([blob], fileName, { type: selectedMime.type });

                            if (navigator.canShare && navigator.canShare({ files: [file] })) {
                                navigator
                                    .share({ files: [file], title: "Kraken Airlines Flight" })
                                    .catch((err) => {
                                        console.warn("Share cancelled or failed", err);
                                    });
                            } else {
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement("a");
                                a.href = url;
                                a.download = fileName;
                                a.click();
                                URL.revokeObjectURL(url);
                            }
                        };

                        isRecording = true;
                        drawFrame();

                        mediaRecorder.start();
                        recordBtn.classList.add("recording");
                        const icon = recordBtn.querySelector(".material-symbols-rounded");
                        const label = recordBtn.querySelector(".label");
                        if (icon) {
                            icon.textContent = "stop_circle";
                        }
                        if (label) {
                            label.textContent = "Stop";
                        }
                    } catch (err) {
                        console.error("Recording error:", err);
                        isRecording = false;
                        recordBtn.classList.remove("recording");
                        const icon = recordBtn.querySelector(".material-symbols-rounded");
                        const label = recordBtn.querySelector(".label");
                        if (icon) {
                            icon.textContent = "fiber_manual_record";
                        }
                        if (label) {
                            label.textContent = "Record";
                        }
                    }
                } else {
                    mediaRecorder.stop();
                    isRecording = false;

                    recordBtn.classList.remove("recording");
                    const icon = recordBtn.querySelector(".material-symbols-rounded");
                    const label = recordBtn.querySelector(".label");
                    if (icon) {
                        icon.textContent = "fiber_manual_record";
                    }
                    if (label) {
                        label.textContent = "Record";
                    }
                }
            });

            // Animation Loop
            let time = 0;

            function animate() {
                requestAnimationFrame(animate);
                time += 0.016;

                switch (currentState) {
                    case PlaneState.IDLE:
                        planeGroup.position.x += (0 - planeGroup.position.x) * 0.08;
                        planeGroup.position.y += (-0.4 - planeGroup.position.y) * 0.08;
                        planeGroup.position.z += (-4.5 - planeGroup.position.z) * 0.08;
                        planeGroup.rotation.x += (0 - planeGroup.rotation.x) * 0.08;
                        planeGroup.rotation.z +=
                            (Math.cos(time * 1.4) * 0.03 - planeGroup.rotation.z) * 0.08;
                        trailPoints.length = 0;
                        break;

                    case PlaneState.DRAGGING:
                        if (handDetected && gestureType === "pinch") {
                            const targetX = THREE.MathUtils.clamp(smoothedHandX * 4.2, -3.2, 3.2);
                            const targetY = THREE.MathUtils.clamp(smoothedHandY * 3.2, -2.2, 2.6);
                            planeGroup.position.x += (targetX - planeGroup.position.x) * 0.25;
                            planeGroup.position.y += (targetY - planeGroup.position.y) * 0.25;
                            planeGroup.position.z += (-6 - planeGroup.position.z) * 0.2;
                            planeGroup.rotation.z += (palmTilt.roll - planeGroup.rotation.z) * 0.2;
                            planeGroup.rotation.x += (palmTilt.pitch - planeGroup.rotation.x) * 0.2;
                        }
                        trailPoints.length = 0;
                        break;

                    case PlaneState.ORBITING:
                        // Smooth circular orbit in center of screen
                        orbitAngle += orbitSpeed;

                        const orbitRadius = THREE.MathUtils.clamp(targetDistance, 3.8, 5.6);
                        targetDistance = orbitRadius;
                        const targetX = Math.cos(orbitAngle) * orbitRadius;
                        const targetY = Math.sin(orbitAngle * 0.55) * 1.4;
                        const targetZ = -6.5 + Math.sin(orbitAngle) * 1.2;

                        // Smooth interpolation to target position
                        planeGroup.position.x += (targetX - planeGroup.position.x) * 0.05;
                        planeGroup.position.y += (targetY - planeGroup.position.y) * 0.05;
                        planeGroup.position.z += (targetZ - planeGroup.position.z) * 0.05;

                        // Look at next point on orbit
                        const lookAheadAngle = orbitAngle + 0.3;
                        const lookX = Math.cos(lookAheadAngle) * orbitRadius;
                        const lookY = Math.sin(lookAheadAngle * 0.55) * 1.2;
                        const lookZ = -6.5 + Math.sin(lookAheadAngle) * 1.2;

                        const lookTarget = new THREE.Vector3(lookX, lookY, lookZ);
                        const currentLook = new THREE.Vector3();
                        planeGroup.getWorldDirection(currentLook);

                        const targetDir = lookTarget.sub(planeGroup.position).normalize();
                        planeGroup.lookAt(planeGroup.position.clone().add(targetDir));

                        planeGroup.rotation.z += (palmTilt.roll - planeGroup.rotation.z) * 0.08;
                        planeGroup.rotation.x += (palmTilt.pitch - planeGroup.rotation.x) * 0.08;
                        break;

                    case PlaneState.CONTROLLED:
                        if (handDetected && gestureType === "pointing") {
                            // Smoothly guide plane toward hand direction
                            const targetControlX = THREE.MathUtils.clamp(
                                smoothedHandX * 5.2,
                                -3.5,
                                3.5,
                            );
                            const targetControlY = THREE.MathUtils.clamp(
                                smoothedHandY * 4.4,
                                -2.3,
                                2.8,
                            );

                            planeGroup.position.x +=
                                (targetControlX - planeGroup.position.x) * 0.08;
                            planeGroup.position.y +=
                                (targetControlY - planeGroup.position.y) * 0.08;

                            // Maintain forward motion
                            planeGroup.position.z += (-6.2 - planeGroup.position.z) * 0.05;

                            // Look at direction of movement
                            const moveDir = new THREE.Vector3(
                                targetControlX - planeGroup.position.x,
                                targetControlY - planeGroup.position.y,
                                -0.5,
                            ).normalize();

                            const targetQuat = new THREE.Quaternion();
                            const lookMatrix = new THREE.Matrix4();
                            lookMatrix.lookAt(
                                planeGroup.position,
                                planeGroup.position.clone().add(moveDir),
                                new THREE.Vector3(0, 1, 0),
                            );
                            targetQuat.setFromRotationMatrix(lookMatrix);
                            planeGroup.quaternion.slerp(targetQuat, 0.1);
                        }
                        planeGroup.rotation.z += (palmTilt.roll - planeGroup.rotation.z) * 0.12;
                        planeGroup.rotation.x += (palmTilt.pitch - planeGroup.rotation.x) * 0.12;
                        break;

                    case PlaneState.TRICK:
                        // Barrel roll animation
                        const trickProgress = (Date.now() % 1500) / 1500;
                        planeGroup.rotation.z = trickProgress * Math.PI * 4;

                        // Continue orbiting during trick
                        orbitAngle += orbitSpeed;
                        const trickRadius = THREE.MathUtils.clamp(targetDistance, 3.8, 5.6);
                        planeGroup.position.x = Math.cos(orbitAngle) * trickRadius;
                        planeGroup.position.y = Math.sin(orbitAngle * 0.55) * 1.2;
                        planeGroup.position.z = -6.5 + Math.sin(orbitAngle) * 1.2;
                        break;
                }

                if (!handDetected) {
                    palmTilt.roll *= 0.9;
                    palmTilt.pitch *= 0.9;
                }

                // Update trail for all states except IDLE and DRAGGING
                if (
                    currentState === PlaneState.ORBITING ||
                    currentState === PlaneState.CONTROLLED ||
                    currentState === PlaneState.TRICK
                ) {
                    trailPoints.push(planeGroup.position.clone());
                    if (trailPoints.length > maxTrailLength) {
                        trailPoints.shift();
                    }

                    const positions = new Float32Array(trailPoints.length * 3);
                    trailPoints.forEach((point, i) => {
                        positions[i * 3] = point.x;
                        positions[i * 3 + 1] = point.y;
                        positions[i * 3 + 2] = point.z;
                    });

                    trailGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
                    trailGeometry.attributes.position.needsUpdate = true;
                }

                renderer.render(scene, camera);
            }

            // Handle resize
            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        </script>
    </body>
</html>
